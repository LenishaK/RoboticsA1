{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      Mouse in a maze \n#\tAuthor:       VEX\n#\tCreated:      18.02.26 \n#\tDescription:  Assignmnet 1 - robotics \n#                 Program the mouse to escape the maze using different algorithms \n# \n# -------------------------------------------\n#Maze solving robot - tremaux + dijkstra algorithms \nfrom vexcode_vr import *\n\nbrain = Brain()\ndrivetrain = Drivetrain(\"drivetrain\", 0)\ndistance = Distance(\"frontdistance\", 6)\nlocation = Location(\"location\", 9)\n#endregion VEXcode Generated Robot Configuration\n\ndef main():\n    STEP = 250           # The robot moves this many MM per move \n    WALL = 80            # Width of the wall, too close to enter \n\n    TARGET_X = -100      # co-ords of the end of the maze \n    TARGET_Y = 900       \n    TOL = 80             # Room for error, for both x and y \n\n    heading = 0          # The direction of the robot and where its going \n\n    marks = {}           # counts the direction adn thehlocation of the robots co-ords \n    path = []\n\n    while True:\n        cx_mm = location.position(X, MM)\n        cy_mm = location.position(Y, MM)\n\n        if abs(cx_mm - TARGET_X) <= TOL and abs(cy_mm - TARGET_Y) <= TOL:\n            break \n\n        # Verfies if the robot is at the target \n        cx = int(round(cx_mm / STEP)) \n        cy = int(round(cy_mm / STEP))\n\n        dirs = [\n            (heading + 1) % 4,\n            heading, \n            (heading + 3) % 4, \n            (heading + 2) % 4 \n        ]\n\n        best_dir = -1 \n        best_mark = 999\n\n        for d in dirs:\n            turn_amount = (d - heading) % 4 \n            if turn_amount == 1:\n                drivetrain.turn_for(RIGHT, 90, DEGREES)\n            elif turn_amount == 3:\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n            elif turn_amount == 2:\n                drivetrain.turn_for(RIGHT, 180, DEGREES)\n\n            dist = distance.get_distance(MM)\n            if dist == -1:\n                dist = 9999\n\n            if turn_amount == 1:\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n            elif turn_amount == 3:\n                drivetrain.turn_for(RIGHT, 90, DEGREES)\n            elif turn_amount == 2:\n                drivetrain.turn_for(RIGHT, 180, DEGREES)\n\n            if dist > WALL: \n                mark = marks.get((cx, cy, d), 0)\n                if mark < best_mark:\n                    best_mark = mark \n                    best_dir = d\n        \n        if best_dir == -1:\n            break \n\n        turn_amount = (best_dir - heading) % 4 \n        if turn_amount == 1:\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n        elif turn_amount == 3:\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n        elif turn_amount == 2:\n            drivetrain.turn_for(RIGHT, 180, DEGREES)\n        \n        heading = best_dir \n\n        marks[(cx, cy, best_dir)] = marks.get((cx, cy, best_dir), 0) + 1 \n        \n        drivetrain.drive_for(FORWARD, STEP, MM)\n \n        if len(path) > 0 and best_dir == (path[-1] + 2) % 4:\n            path.pop()\n        else:\n            path.append(best_dir)\n\n        wait(0.02, SECONDS)\n\n\n        i = len(path) - 1\n        while i >= 0:\n\n            back_dir = (path[i] + 2) % 4 \n\n            turn_amount = (back_dir - heading) % 4 \n            if turn_amount == 1:\n                drivetrain.turn_for(RIGHT, 90, DEGREES)\n            elif turn_amount == 3:\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n            elif turn_amount == 2:\n                drivetrain.turn_for(RIGHT, 180, DEGREES)\n\n            heading = back_dir \n            drivetrain.drive_for(FORWARD, STEP, MM)\n\n            i -= 1\n        \n        drivetrain.stop()\n\nvr_thread(main)\n\n\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.63.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"playground":"DynamicWallMaze","robotModel":"vr"}