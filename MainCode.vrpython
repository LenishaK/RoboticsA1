{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      Mouse in a maze \n#\tAuthor:       VEX\n#\tCreated:      18.02.26 \n#\tDescription:  Assignmnet 1 - robotics \n#                 Program the mouse to escape the maze using different algorithms \n# \n# -------------------------------------------\n#Maze solving robot - tremaux + dijkstra algorithms \nfrom vexcode_vr import *\n\nbrain = Brain()\ndrivetrain = Drivetrain(\"drivetrain\", 0)\ndistance = Distance(\"frontdistance\", 6)\nlocation = Location(\"location\", 9)\n#endregion VEXcode Generated Robot Configuration\n\ndef main():\n    STEP = 250           # The robot moves this many MM per move \n    WALL = 80            # Width of the wall, too close to enter \n\n    TARGET_X = -100      # co-ords of the end of the maze \n    TARGET_Y = 900       \n    TOL = 80             # Room for error, for both x and y \n\n    heading = 0          # The direction of the robot and where its going \n\n    marks = {}           # counts the direction adn thehlocation of the robots co-ords \n    path = []\n\n    explored = {}        # explored cells + graph for the shorest path\n    graph = {}\n\n    start_x = int(round(location.position(X, MM) / STEP))\n    start_y = int(round(location.position(Y, MM) / STEP))\n    start = (start_x, start_y)\n\n    goal = None\n\n    while True:\n        cx_mm = location.position(X, MM)\n        cy_mm = location.position(Y, MM)\n\n        if abs(cx_mm - TARGET_X) <= TOL and abs(cy_mm - TARGET_Y) <= TOL:\n            goal = cur_cell\n            break \n\n        # Verfies if the robot is at the target \n        cx = int(round(cx_mm / STEP)) \n        cy = int(round(cy_mm / STEP))\n        cur_cell = (cx, cy)\n\n        right_dir = (heading + 1) % 4\n        fwd_dir   = heading\n        left_dir  = (heading + 3) % 4\n        back_dir  = (heading + 2) % 4\n\n        best_dir = -1 \n        best_mark = 999\n\n        check_list = [right_dir, fwd_dir, left_dir, back_dir]\n\n        i = 0\n        while i < 4:\n\n            dcheck = check_list[i]\n\n            turn_amount = (dcheck - heading) % 4\n            if turn_amount == 1:\n                drivetrain.turn_for(RIGHT, 90, DEGREES)\n            elif turn_amount == 3:\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n            elif turn_amount == 2:\n                drivetrain.turn_for(RIGHT, 180, DEGREES)\n\n            dist = distance.get_distance(MM)\n            if dist == -1:\n                dist = 9999\n\n            if turn_amount == 1:\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n            elif turn_amount == 3:\n                drivetrain.turn_for(RIGHT, 90, DEGREES)\n            elif turn_amount == 2:\n                drivetrain.turn_for(RIGHT, 180, DEGREES)\n\n            if dist > WALL:\n                m = marks.get((cx, cy, dcheck), 0)\n                if m < best_mark:\n                    best_mark = m\n                    best_dir = dcheck\n\n            i += 1\n\n            \n        if best_dir == -1:\n            break \n\n        turn_amount = (best_dir - heading) % 4 \n        if turn_amount == 1:\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n        elif turn_amount == 3:\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n        elif turn_amount == 2:\n            drivetrain.turn_for(RIGHT, 180, DEGREES)\n        \n        heading = best_dir \n\n        key = (cx, cy, best_dir)\n        marks[key] = marks.get(key, 0) + 1\n\n        prev_cell = cur_cell\n        drivetrain.drive_for(FORWARD, STEP, MM)\n\n        nx = int(round(location.position(X, MM) / STEP))\n        ny = int(round(location.position(Y, MM) / STEP))\n        new_cell = (nx, ny)\n\n        explored[new_cell] = True\n        if new_cell not in graph:\n            graph[new_cell] = []\n\n        if prev_cell not in graph[new_cell]:\n            graph[new_cell].append(prev_cell)\n        \n        if prev_cell not in graph:\n            graph[prev_cell] = []\n\n        if new_cell not in graph[prev_cell]:\n            graph[prev_cell].append(new_cell)\n\n        opp = (best_dir + 2) % 4\n        key2 = (nx, ny, opp)\n        marks[key2] = marks.get(key2, 0) + 1\n        \n        if len(path) > 0 and best_dir == (path[-1] + 2) % 4:\n            path.pop()\n        else:\n            path.append(best_dir)\n\n        wait(0.02, SECONDS)\n\n    if goal is None:\n        drivetrain.stop()\n        return\n\n\n        #BFS calculates the shortest route\n        parent = {}\n        q = [goal]\n        parent[goal] = None\n\n        while len(q) > 0:\n            u = q.pop(0)\n            for v in graph.get(u, []):\n                if v not in parent:\n                    parent[v] = u\n                    q.append(v)\n\n    route = {}\n    fastest_back = []\n\n    brain.clear()\n    if start in parent:\n        brain.print(\"RETURN: BFS\")\n    else:\n        brain.print(\"RETURN: RETRACE\")\n    brain.new_line()\n\n    if start in parent:\n\n        path_start_to_goal = []\n        cur = start\n        while cur is not None:\n            path_start_to_goal.append(cur)\n            cur = parent[cur]\n\n        fastest_back = list(reversed(path_start_to_goal))\n\n        i = 0\n        while i < len(fastest_back):\n            route[fastest_back[i]] = True\n            i += 1\n\n\n    #ASCII grid\n    #prevents overflow\n    MAX_ROWS = 18   # number of map lines\n    MAX_COLS = 30   # characters per line\n\n    xs = [p[0] for p in explored]\n    ys = [p[1] for p in explored]\n    minx, maxx = min(xs), max(xs)\n    miny, maxy = min(ys), max(ys)\n\n    brain.print(\"S=start G=goal *=fastest\")\n    brain.new_line()\n\n    row_count = 0\n    y = maxy\n    while y >= miny and row_count < MAX_ROWS:\n\n        line = \"\"\n        x = minx\n        while x <= maxx and len(line) < MAX_COLS:\n            p = (x, y)\n            ch = \" \"\n            if p in explored:\n                ch = \".\"\n            if p in route:\n                ch = \"*\"\n            if p == start:\n                ch = \"S\"\n            if p == goal:\n                ch = \"G\"\n            line += ch\n            x += 1\n\n        brain.print(line)\n        brain.new_line()\n\n        row_count += 1\n        y -= 1\n\n\n    #return back home movement \n    if start in parent:\n\n        current = goal\n        i = 1\n        while i < len(fastest_back):\n\n            next_cell = fastest_back[i]\n\n            x1, y1 = current\n            x2, y2 = next_cell\n\n            if x2 == x1 and y2 == y1 + 1:\n                d = 0\n            elif x2 == x1 + 1 and y2 == y1:\n                d = 1\n            elif x2 == x1 and y2 == y1 - 1:\n                d = 2\n            else:\n                d = 3\n\n            turn_amount = (d - heading) % 4\n            if turn_amount == 1:\n                drivetrain.turn_for(RIGHT, 90, DEGREES)\n            elif turn_amount == 3:\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n            elif turn_amount == 2:\n                drivetrain.turn_for(RIGHT, 180, DEGREES)\n\n            heading = d\n            drivetrain.drive_for(FORWARD, STEP, MM)\n\n            current = next_cell\n            i += 1\n\n    else:\n        i = len(path) - 1\n        while i >= 0:\n\n            back_dir = (path[i] + 2) % 4\n\n            turn_amount = (back_dir - heading) % 4\n            if turn_amount == 1:\n                drivetrain.turn_for(RIGHT, 90, DEGREES)\n            elif turn_amount == 3:\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n            elif turn_amount == 2:\n                drivetrain.turn_for(RIGHT, 180, DEGREES)\n\n            heading = back_dir\n            drivetrain.drive_for(FORWARD, STEP, MM)\n\n            i -= 1\n\n    drivetrain.stop()\n\n\nvr_thread(main)\n\n        ","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.63.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"playground":"DynamicWallMaze","robotModel":"vr"}